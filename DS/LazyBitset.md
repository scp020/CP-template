### 一、模板类别

​	数据结构：带懒惰标记的动态开点位集

​	练习题目：

1. [2166. 设计位集](https://leetcode.cn/problems/design-bitset/)
2. [P5057 [CQOI2006] 简单题](https://www.luogu.com.cn/problem/P5057)

### 二、模板功能

#### 1.建立位集

1. 数据类型

   类型设定 `index_type = uint32_t` ，表示树中结点在内存池上的下标的类型。

   模板参数 `typename SizeType` ，表示表示区间长度时，所采用的数的类型。在区间长度为 `1e9` 级别时，采用 `uint32_t` 为佳；区间长度更长时，采用 `uint64_t` 。当然采用有符号数也无大碍。

   模板参数 `SizeType MAX_NODE` ，表示最大结点数，默认为 `1<<22` 。

   构造参数 `SizeType length` ，表示位集的覆盖范围为 `[0, length)`。默认值为 `0` 。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   在标准库中有 `std::bitset` 可以作为位集，但是 `std::bitset` 有长度无法改变、无法进行区间修改、区间查询的缺点。本数据结构实现了区间赋值、区间翻转、区间查询 `1` 的数量的功能。

   在另一文件中，已经实现了 `OY::Bitset::Table` 这一数据结构。但是该数据结构创建的时间复杂度是线性，面对上亿长度时力不从心。本数据结构以动态开点、懒惰更新的思想进行优化，在牺牲一定常数效率的基础上，支持了上亿长度。

   本数据结构没有实现按位左移和按位右移的功能。

#### 2.重置(resize)

1. 数据类型

   输入参数 `SizeType length` ，表示位集的大小为 `length`。

2. 时间复杂度

    $O(1)$ 。

####  3.全部置为1(set)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `1` 。

#### 4.将某一位置为1(set)

1. 数据类型

   输入参数 `SizeType i` ，表示将下标 `i` 位置置为 `1` 。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 5.将某一区间置为1(set)

1. 数据类型

   输入参数 `SizeType left` ，表示要修改的区间的起始下标。

   输入参数 `SizeType right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  6.全部置为0(reset)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `0` 。

#### 7.将某一位置为0(reset)

1. 数据类型

   输入参数 `SizeType i` ，表示将下标 `i` 位置置为 `0` 。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 8.将某一区间置为0(reset)

1. 数据类型

   输入参数 `SizeType left` ，表示要修改的区间的起始下标。

   输入参数 `SizeType right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  9.全部翻转(flip)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将位集的每一位翻转。

#### 10.将某一位置翻转(flip)

1. 数据类型

   输入参数 `SizeType i` ，表示将下标 `i` 翻转。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 11.将某一区间翻转(flip)

1. 数据类型

   输入参数 `SizeType left` ，表示要修改的区间的起始下标。

   输入参数 `SizeType right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 12.查询1的总数(count)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 13.查询区间中1的总数(count)

1. 数据类型

   输入参数 `SizeType left` ，表示要查询的区间的起始下标。

   输入参数 `SizeType right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 14.查询是否有1(any)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 15.查询区间中是否有1(any)

1. 数据类型

   输入参数 `SizeType left` ，表示要查询的区间的起始下标。

   输入参数 `SizeType right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 16.查询是否全为1(all)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 17.查询区间中是否全为1(all)

1. 数据类型

   输入参数 `SizeType left` ，表示要查询的区间的起始下标。

   输入参数 `SizeType right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 18.查询第一个1的位置(first_one)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

#### 19.查询最后一个1的位置(last_one)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

#### 20.查询第一个0的位置(first_zero)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `1` ，没有 `0` 时，返回 `-1` 。

#### 21.查询最后一个0的位置(last_zero)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `1` ，没有 `0` 时，返回 `-1` 。

#### 22.查询前一个1的位置(prev_one)

1. 数据类型

   输入参数 `SizeType i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之前全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 23.查询后一个1的位置(next_one)

1. 数据类型

   输入参数 `SizeType i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之后全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 24.查询前一个0的位置(prev_zero)

1. 数据类型

   输入参数 `SizeType i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之前全部都是 `1` ，没有 `0` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 25.查询后一个0的位置(next_zero)

1. 数据类型

   输入参数 `SizeType i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之后全部都是 `1` ，没有 `0` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 26.查询某下标(at)

1. 数据类型

   输入参数 `SizeType i` ，表示要查询的下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 27.查询第k个1(kth)

1. 数据类型

   输入参数 `SizeType k` ，表示要查询的排名。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）


#### 三、模板示例

```c++
#include "DS/LazyBitset.h"
#include "IO/FastIO.h"

int main() {
    OY::LazyBitset::Tree<uint32_t, 10000> B(100000000);
    // 将区间置为 1
    B.set(10000000, 30000000);
    cout << "B[10000000~20000000]=" << B.count(10000000, 20000000) << endl;
    // 将区间置为 0
    B.reset(5000000, 14000000);
    cout << "B[10000000~20000000]=" << B.count(10000000, 20000000) << endl;
    // 将整个位集翻转
    B.flip();
    cout << "B[10000000~20000000]=" << B.count(10000000, 20000000) << endl;

    for (int i = 13950000; i < 14050000; i += 10000)
        cout << "index " << i << ":" << B.at(i) << endl;

    // 全部置为 0
    B.reset();

    B.set(160000);
    B.set(9800000);
    B.set(3570000);
    B.set(20000);
    for (int i = B.first_one(); i >= 0; i = B.next_one(i))
        cout << i << ' ';
    cout << endl;
    for (int i = B.last_one(); i >= 0; i = B.prev_one(i))
        cout << i << ' ';
    cout << endl;
}
```

```
#输出如下
B[10000000~20000000]=10000001
B[10000000~20000000]=6000000
B[10000000~20000000]=4000001
index 13950000:1
index 13960000:1
index 13970000:1
index 13980000:1
index 13990000:1
index 14000000:1
index 14010000:0
index 14020000:0
index 14030000:0
index 14040000:0
20000 160000 3570000 9800000 
9800000 3570000 160000 20000 

```

