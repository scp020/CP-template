### 一、模板类别

​	数据结构：差分。

​	练习题目：

1. [Minimum Sum](https://acm.hdu.edu.cn/showproblem.php?pid=3473)
2. [Best Reward](https://acm.hdu.edu.cn/showproblem.php?pid=3613)
3. [P1117 [NOI2016] 优秀的拆分](https://www.luogu.com.cn/problem/P1117)
4. [P2367 语文成绩](https://www.luogu.com.cn/problem/P2367)
5. [fsl 的背包](https://ac.nowcoder.com/acm/problem/263978)


### 二、模板功能

#### 1.初始化

1. 数据类型

   类型设定 `size_type = uint32_t` ，表示数组大小、编号的类型。

   模板参数 `typename Tp` ，表示元素类型。

   模板参数 `bool AutoSwitch` ，表示是否自动切换状态。

   模板参数 `size_type MAX_NODE` ，表示最大结点数，默认为 `1<<22` 。

   构造参数 `size_type length`  ，表示维护的区间下标范围为 `[0, length-1]` 。

   构造参数 `InitMapping mapping` ，表示在初始化时，从下标到值的映射函数。默认为 `AdjDiff::Ignore` 。接收类型可以为普通函数，函数指针，仿函数，匿名函数，泛型函数等。

2. 时间复杂度

   当 `mapping` 参数为 `Ignore` 对象时，为 $O(1)$ ；否则为 $O(n)$ ，其中 `n` 表示区间长度。

3. 备注

   本数据结构，处于三种状态之一，且可以随时切换。

   当处于差分态 `TABLE_DIFFERENCE` 时，便于进行“将某个子数组增加一定的值”操作；

   当处于值态时 `TABLE_VALUE` ，便于进行“将某个点增加一定的值”或者“查询某点的值”操作；

   当处于前缀和态 `TABLE_PRESUM` 时，便于进行“查询某个子数组的和”操作。

   状态切换需要 $O(n)$ 的时间，所以使用时尽量避免频繁切换状态。

   如果担心忘记切换状态，可以将 `AutoSwitch` 设为 `true` ，则在调用函数时会自动切换到最合适的状态。

   **注意：**

   构造参数中的 `mapping` 参数，入参为下标，返回值须为一个 `Tp` 对象。默认情况下， `mapping` 为 `AdjDiff::Ignore` 类，表示不进行初始化，比如要建立一颗空的差分表，由于全局变量值本身就是零，所以无需进行初始化，此时的初状态为 `TABLE_ANY` 态，可以认为为任意状态。如果进行了有意义的初始化，则初状态为 `TABLE_VALUE` 态。

#### 2.初始化

1. 数据类型

   构造参数 `Iterator first` ，表示区间维护的区间头。

   构造参数 `Iterator last` ，表示区间维护的区间尾。（开区间）

   其它同上。

2. 时间复杂度

   同上。

3. 备注

   同上。

   使用迭代器进行初始化，可以将区间初状态直接赋到表里。

#### 3.重置(resize)

1. 数据类型

   输入参数 `size_type length`  ，表示维护的行范围为 `[0, length-1]` 。

   输入参数 `InitMapping mapping` ，表示在初始化时，从下标到值的映射函数。默认为 `AdjDiff::Ignore` 。

2. 时间复杂度

   当 `mapping` 参数为 `Ignore` 对象时，为 $O(1)$ ；否则为 $O(n)$ ，其中 `n` 表示区间长度。

3. 备注

   使用映射函数进行初始化，可以将区间初状态直接赋到差分表里。

   构造参数中的 `mapping` 参数，入参为下标，返回值须为一个 `Tp` 对象。在调用时，会按照行下标从 `0` 到 `length-1` 依次调用。
   
   本函数没有进行参数检查，所以请自己确保下标合法。（位于 `[0，n)`）

#### 4.重置(reset)

1. 数据类型

   输入参数 `Iterator first` ，表示区间维护的区间头。

   输入参数 `Iterator last` ，表示区间维护的区间尾。（开区间）

2. 时间复杂度

   同上。

3. 备注

   同上。

   使用迭代器进行重置，可以将区间初状态直接赋到表里。

   
#### 5.单点增值(add)

1. 数据类型

   输入参数 `size_type i` ，表示要增值的点所在下标。

   输入参数 `const Tp &inc`​ ，表示要增加的值。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在值态下进行。

   本函数没有进行参数检查，所以请自己确保下标合法。（行号位于 `[0，n)`）

#### 6.单点赋值(modify)

1. 数据类型

   输入参数 `size_type i` ，表示要赋值的点所在下标。

   输入参数 `const Tp &inc`​ ，表示要赋的值。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在值态下进行。

   本函数没有进行参数检查，所以请自己确保下标合法。（行号位于 `[0，n)`）

#### 7.区间增值(add)

1. 数据类型

   输入参数 `size_type left` ，表示要增值的区间的开始下标。

   输入参数 `size_type right` ，表示要增值的区间的结尾下标。（闭区间）

   输入参数 `const Tp &inc`​ ，表示要增加的值。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在差分态下进行。

   本函数没有进行参数检查，所以请自己确保下标合法。（行号位于 `[0，n)`）

#### 8.单点查询(query)

1. 数据类型

   输入参数 `size_type i` ，表示要增值的点所在下标。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在值态下进行。

   本函数没有进行参数检查，所以请自己确保下标合法。（行号位于 `[0，n)`）

#### 9.区间查询(query)

1. 数据类型

   输入参数 `size_type left` ，表示要查询的子数组的开始下标。

   输入参数 `size_type right` ，表示要查询的子矩形的结尾下标。（闭区间）

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在前缀和态下进行。

   本函数没有进行参数检查，所以请自己确保下标合法。（行号位于 `[0，n)`）

#### 10.查询全部(query_all)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在前缀和态下进行。


#### 11.切换状态到差分态(switch_to_difference)

1. 数据类型

2. 时间复杂度

   $O(n)$ 。

3. 备注

   切换到差分态，以便进行区间修改。

#### 12.切换状态到值态(switch_to_value)

1. 数据类型

2. 时间复杂度

   $O(n)$ 。

3. 备注

   切换到值态，以便进行单点修改和单点查询。

   **注意：**如果要进行整表输出，也请切换到值态。

#### 13.切换状态到前缀和态(switch_to_presum)

1. 数据类型

2. 时间复杂度

   $O(n)$ 。

3. 备注

   切换到前缀和态，以便进行区间查询。


### 三、模板示例

```c++
#include "DS/AdjDiff.h"
#include "IO/FastIO.h"

int main() {
    OY::AdjDiff::Table<int, true> ad(5);

    cout << ad << endl;

    ad.switch_to_value();
    ad.add(1, 10);
    ad.add(2, 100);
    cout << ad << endl;

    ad.switch_to_difference();
    ad.add(2, 4, 1000);

    ad.switch_to_value();
    cout << ad << endl;
}
```

```
#输出如下
[0, 0, 0, 0, 0]
[0, 10, 100, 0, 0]
[0, 10, 1100, 1000, 1000]

```

