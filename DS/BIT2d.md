### 一、模板类别

​	数据结构：二维树状数组

​	练习题目：

1. [#133. 二维树状数组 1：单点修改，区间查询](https://loj.ac/p/133)
2. [#134. 二维树状数组 2：区间修改，单点查询](https://loj.ac/p/134)
3. [#135. 二维树状数组 3：区间修改，区间查询](https://loj.ac/p/135)
4. [P4054 [JSOI2009] 计数问题](https://www.luogu.com.cn/problem/P4054)
5. [P4514 上帝造题的七分钟](https://www.luogu.com.cn/problem/P4514)

### 二、模板功能

#### 1.建立二维树状数组

1. 数据类型

   类型设定 `size_type = uint32_t` ，表示树状数组中下标编号的变量类型。
   
   模板参数 `typename Tp` ，表示元素类型。

   模板参数 `bool RangeUpdate`​ ，表示是否要支持区域修改。

   模板参数 `size_type MAX_NODE` ，表示最大结点数，默认为 `1<<22` 。

   构造参数 `size_type row` ，表示二维树状数组的行范围为 `[0, row)`。

   构造参数 `size_type column` ，表示二维树状数组的列范围为 `[0, column)`。

   构造参数 `InitMapping mapping` ，表示在初始化时，从下标到值的映射函数。默认为 `BIT2D::Ignore` 。接收类型可以为普通函数，函数指针，仿函数，匿名函数，泛型函数等。

2. 时间复杂度

   当 `mapping` 参数为 `Ignore` 对象时，为 $O(1)$ ；否则为 $O(m\cdot n)$ ，其中 `m` 和 `n` 分别表示行数和列数。

3. 备注

   二维树状数组处理的问题为单点修改，单点/区域和的查询。当 `RangeUpdate` 参数设置为 `true` 时，可以同时兼备区域增值修改的功能，但是时空效率都会下降。

   本二维树状数组模板与之前版本的重大区别为，不再支持乘法/除法或者其他类型的模板函数传递，转而要求树中元素类型支持加减法运算。如果确实有进行区域乘积维护的需求，使用者须自定义一个类作为元素类型。

   二维树状数组通过加和函数求解前缀和，再通过前缀和做差求解任意区域和。

   二维树状数组通过一些差分运算，实现了区域修改。

   本构造方法要求元素支持 `+=` 运算符。当 `RangeUpdate` 为 `true` 时，要求元素支持 `-` (减法)， `-` (负号)， `+=` 和 `*` 运算符。

   **注意：**

   构造参数中的 `mapping` 参数，入参为行下标、列下标，返回值须为一个 `Tp` 对象。默认情况下， `mapping` 为 `BIT2D::Ignore` 类，表示不进行初始化，比如要建立一颗空的求和二维树状数组，由于全局变量值本身就是零，所以无需进行初始化。


####  2.重置(resize)

1. 数据类型

   输入参数 `size_type row` ，表示二维树状数组的行范围为 `[0, row)`。

   输入参数 `size_type column` ，表示二维树状数组的列范围为 `[0, column)`。

   输入参数 `InitMapping mapping` ，表示初始化时，从下标到值的映射函数。

2. 时间复杂度

   当 `mapping` 参数为 `Ignore` 对象时，为 $O(1)$ ；否则为 $O(m*n)$ ，其中 `m` 和 `n` 分别表示行数和列数。

3. 备注

   使用映射函数进行初始化，可以将区间初状态直接赋到二维树状数组里。

   构造参数中的 `mapping` 参数，入参为行下标、列下标，返回值须为一个 `Tp` 对象。在调用时，会按照行下标从 `0` 到 `row-1` 、列下标从 `0` 到 `column-1` 依次调用。

   本方法要求元素支持 `+=` 运算符。当 `RangeUpdate` 为 `true` 时，要求元素支持 `-` (减法)， `-` (负号)， `+=` 和 `*` 运算符。

#### 3.单点增值(add)

1. 数据类型

   输入参数 `size_type i` ，表示单点增值的行下标。

   输入参数 `size_type j` ，表示单点增值的列下标。

   输入参数 `const Tp &inc​` ，表示增量大小。

2. 时间复杂度

   $O(\log m\cdot\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

   本构造方法要求元素支持 `+=` 运算符。当 `RangeUpdate` 为 `true` 时，要求元素支持 `-` (负号)， `+=` 和 `*` 运算符。

#### 4.区域增值(add)

1. 数据类型

   输入参数 `size_type row1` ，表示区域增值的起始行下标。

   输入参数 `size_type row2` ，表示区域增值的结束行下标。（闭区间）

   输入参数 `size_type column1​` ，表示区域增值的起始列下标。

   输入参数 `size_type column2` ，表示区域增值的结束列下标。（闭区间）

   输入参数 `const Tp &inc` ，表示增量大小。

2. 时间复杂度

   $O(\log m\cdot\log n)$ 。

3. 备注

   本方法仅当 `RangeUpdate` 为 `true` 时合法。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

   本构造方法要求元素支持 `-` (负号)， `+=` 和 `*` 运算符。

#### 5.前缀和查询(presum)

1. 数据类型

   输入参数 `size_type i`，表示前缀和查询的结尾行下标。(闭区间)

   输入参数 `size_type j`，表示前缀和查询的结尾列下标。(闭区间)

2. 时间复杂度

   $O(\log m\cdot\log n)$ 。
   
3. 备注

   虽然名义上为**前缀和**，但是实际上指的是位于点 $[i,\space j]$ 左上方的区域和。（包括 `i` 行 `j` 列）

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

   本方法要求元素支持 `+=` 运算符。当 `RangeUpdate` 为 `true` 时，要求元素支持 `-` (负号)， `+=` 和 `*` 运算符。

#### 6.单点查询(query)

1. 数据类型

   输入参数 `size_type i` ，表示单点查询的行下标。

   输入参数 `size_type j` ，表示单点查询的列下标。

2. 时间复杂度

   $O(\log m\cdot\log n)$ 。

3. 备注

   本方法只有在做差函数合理的时候有意义。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

   本方法要求元素支持 `-=` 运算符。当 `RangeUpdate` 为 `true` 时，要求元素支持 `+=` 运算符。

#### 7.区域查询(presum)

1. 数据类型

   输入参数 `size_type row1` ，表示区域查询的起始行下标。

   输入参数 `size_type row2` ，表示区域查询的结束行下标。（闭区间）

   输入参数 `size_type column1​` ，表示区域查询的起始列下标。

   输入参数 `size_type column2` ，表示区域查询的结束列下标。（闭区间）

2. 时间复杂度

   $O(\log m\cdot\log n)$ 。
   
3. 备注

   本方法只有在做差函数合理的时候有意义。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

   本方法要求元素支持  `-` (减法) 和 `+=` 运算符。当 `RangeUpdate` 为 `true` 时，要求元素支持 `-` (减号)， `+=` 和 `*` 运算符。

#### 8.查询全部(query_all)

1. 数据类型

2. 时间复杂度

   $O(\log m\cdot\log n)$ 。

### 三、模板示例

```c++
#include "DS/BIT2D.h"
#include "IO/FastIO.h"

int main() {
    // 二维树状数组与一维树状数组的用法基本类似，所以只展示一下初始化的特殊方法
    int matrix[4][5] = {
        {3, 0, 1, 4, 2},
        {5, 6, 3, 2, 1},
        {1, 2, 0, 1, 5},
        {4, 1, 0, 1, 7},
    };
    // 除了行数、列数，还需要传递一个寻址函数
    OY::BIT2D64<true, 1000> T(4, 5, [&](int i, int j) { return matrix[i][j]; });
    cout << T << endl;
    // 输出[0,2]行，[1,4]列的和
    cout << "sum(matrix[0~2][1~4])=" << T.query(0, 2, 1, 4) << endl;

    // 对中间腹部地带进行区域加
    T.add(1, 2, 1, 3, 100);
    cout << T << endl;
    // 再次输出[0,2]行，[1,4]列的和
    cout << "sum(matrix[0~2][1~4])=" << T.query(0, 2, 1, 4) << endl;
}
```

```
#输出如下
[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7]]
sum(matrix[0~2][1~4])=27
[[3, 0, 1, 4, 2], [5, 106, 103, 102, 1], [1, 102, 100, 101, 5], [4, 1, 0, 1, 7]]
sum(matrix[0~2][1~4])=627

```

