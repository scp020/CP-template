### 一、模板类别

​	数据结构：二维线段树（树状数组套动态开点线段树）

​	练习题目：

1. [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)
2. [P3380 【模板】二逼平衡树（树套树）](https://www.luogu.com.cn/problem/P3380)
3. [P3834 【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)
4. [P4054 [JSOI2009] 计数问题](https://www.luogu.com.cn/problem/P4054)


### 二、模板功能

#### 1.建立二维线段树

1. 数据类型

   类型设定 `index_type = uint32_t` ，表示树中结点在内存池上的下标。

   模板参数 `typename Node` ，表示结点类型。

   模板参数 `typename RangeMapping` ，表示从区域映射到区域聚合值的映射函数所属的类。

   模板参数 `typename SizeType` ，表示表示区域大小时，所采用的数的类型。在区间长度为 `1e9` 级别时，采用 `uint32_t` 为佳；区间长度更长时，采用 `uint64_t` 。当然采用有符号数也无大碍。

   模板参数 `index_type MAX_TREENODE` ，表示最大树结点数，默认为 `1<<20` 。

   模板参数 `index_type MAX_NODE` ，表示最大结点数，默认为 `1<<23` 。

   构造参数 `index_type row` ，表示线段树的行范围为 `[0, row)`。默认值为 `0` 。

   构造参数 `SizeType column` ，表示线段树的列范围为 `[0, column)`。默认值为 `0` 。

   构造参数 `InitMapping init_mapping` ，表示在初始化时，从区域到区域聚合值的映射函数。默认为 `SegBIT::Ignore` 。接收类型可以为普通函数，函数指针，仿函数，匿名函数，泛型函数等。

2. 时间复杂度

   当 `Complete` 参数为 `true` 时，为 $O(m\cdot n)$ ，其中 `m` 和 `n` 分别表示行数和列数；否则为 $O(1)$ 。

3. 备注

   二维线段树处理的问题为单点修改，单点/区域和的查询。

   `SegBIT` 和普通二维线段树相比，在空间上紧凑很多，时间效率高很多。在使用加减法求解求和类问题时，可以认为是改良版的二维线段树。

   但是，由于外层是树状数组，所以必须利用差分来进行任意区域的查询。在面对最值查询等问题时，由于不能像加减法一样找到合适的逆运算，所以无法利用差分进行任意区域的查询。

   本二维线段树模板与之前版本的重大区别为，不再支持乘法/除法或者其他类型的模板函数传递，目前二维线段树的大量细节都放到了模板参数 `Node` 中，只需要设计好 `Node` 即可让线段树工作。

   对于二维线段树来说，结点须满足以下要求：

   1. 声明 `value_type` 为值类型；
   2. 实现成员函数 `set` ，接受一个 `value_type` 参数，将此值赋给本结点；
   3. 实现成员函数 `get` ，返回本结点的值。
   

一般的，我们称 `op` 函数执行的是聚合操作，二维线段树要求区间操作函数的运算符满足**结合律**和**交换律**。

**注意：**

模板参数中的 `RangeMapping` 类型，用于生成仿函数，入参为区域的首行下标、末行下标、首列下标、末列下标，返回值须为一个 `value_type` 对象，表示这个区域的初始聚合值。默认情况下， 为 `SegBIT::Ignore` 类，表示不进行初始化，比如要建立一颗空的求和线段树，由于全局变量值本身就是零，所以无需进行初始化。

**注意：**

本模板部分与 `ZkwTree2D` 模板相似，部分与 `SegTree2D` 模板相似。

与前者相比，本模板重点突出加减法功能，在加减法上速度更快；在第二维度上可以离散化处理很大的值域。

与后者相比 ，本模板重点突出加减法功能，在加减法上速度更快。

由于 `SegBIT` 不需要在一开始就初始化全部的结点，但有时 `SegBIT` 需要一开始就全局初始化，所以产生了 `Complete` 参数和 `RangeMapping` 参数。尤其是 `RangeMapping` 参数，接受区间的左、右端点下标，返回这个区间的聚合值。假想有个情境下，初始时，值与行列下标均呈一次函数关系，但是区间长度达到 `1e9` 。如果用 `ZkwTree2D` 显然不能维护这么大的区间；此时 `SegBIT` 就游刃有余。对任何一个区域，都可以用梯形公式算出区间和，所以只初始化问题涉及到的点链即可。

   显然， `InitMapping` 函数和 `RangeMapping` 函数互斥，当开局就全部初始化时，可以传递 `InitMapping` ，但是肯定不需要 `RangeMapping` 参数，因为区间聚合值都可以通过子结点 `pushup` 得到；如果开局不全部初始化，可以传递 `RangeMapping` 参数，但是不需要传递 `InitMapping` 参数。


####  2.重置(resize)

1. 数据类型

   输入参数 `index_type row` ，表示二维线段树的行范围为 `[0, row)`。

   输入参数 `SizeType column` ，表示二维线段树的列范围为 `[0, column)`。

   构造参数 `InitMapping init_mapping` ，表示在初始化时，从行列下标到值的映射函数。

2. 时间复杂度

   $O(m\cdot n)$ 。

3. 备注

   使用映射函数进行初始化，可以将区间初状态直接赋到线段树里。
   
   参数中的 `mapping` 参数，入参为行下标、列下标，返回值须为一个 `value_type` 对象。在调用时，会按照行下标从 `0` 到 `row-1` 、列下标从 `0` 到 `column-1` 依次调用。

#### 3.单点增值(add)

1. 数据类型

   输入参数 `index_type i` ，表示单点增值的行下标。

   输入参数 `SizeType j` ，表示单点增值的列下标。

   输入参数 `const modify_type &modify​` ，表示增量大小。

2. 时间复杂度

   $O(\log (m\cdot n))$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 4.单点赋值(modify)

1. 数据类型

   输入参数 `index_type i` ，表示单点赋值的行下标。

   输入参数 `SizeType j` ，表示单点赋值的列下标。

   输入参数 `const value_type &val​` ，表示赋的值。

2. 时间复杂度

   $O(\log (m\cdot n))$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 5.查询某列的前缀和(presum)

1. 数据类型

   输入参数 `index_type i` ，表示查询的行下标。

   输入参数 `SizeType j` ，表示查询的列下标。

2. 时间复杂度

   $O(\log(m\cdot n))$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`

#### 6.单点查询(query)

1. 数据类型

   输入参数 `index_type row` ，表示单点查询的行下标。

   输入参数 `SizeType column` ，表示单点查询的列下标。

2. 时间复杂度

   $O(\log(m\cdot n))$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 7.查询一些列的前缀和(presum)

1. 数据类型

   输入参数 `index_type i` ，表示查询的行下标。

   输入参数 `SizeType column1` ，表示查询的起始列下标。

   输入参数 `SizeType column2` ，表示查询的结束列下标。（闭区间）

2. 时间复杂度

   $O(\log(m\cdot n))$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 8.区域查询(query)

1. 数据类型

   输入参数 `index_type row1` ，表示区域查询的起始行下标。

   输入参数 `index_type row2` ，表示区域查询的结束行下标。（闭区间）

   输入参数 `SizeType column1​` ，表示区域查询的起始列下标。

   输入参数 `SizeType column2` ，表示区域查询的结束列下标。（闭区间）

2. 时间复杂度

   $O(\log(m\cdot n))$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 9.查询全部(query_all)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。
   
3. 备注

   本函数与其他函数的时间复杂度不同。

#### 10.从某些行中查询第k个元素(kth)

1. 数据类型

   输入参数 `index_type row1` ，表示区域查询的起始行下标。

   输入参数 `index_type row2` ，表示区域查询的结束行下标。（闭区间）

   输入参数 `value_type k​` ，表示查询的名次。

2. 时间复杂度

   $O(\log(m\cdot n))$ 。

3. 备注

   本函数可以这样表述：找到最小的列号 `c` ，使得 `query(row1, row2, 0, c) >= k + 1` 成立。

   本函数常用于维护带修区间第 `k` 大元素。

### 三、模板示例

```c++
#include "DS/SegBIT.h"
#include "IO/FastIO.h"

int main() {
    // 二维线段树与一维线段树的用法基本类似，所以只展示一下特殊方法
    int matrix[4][5] = {
        {3, 0, 1, 4, 2},
        {5, 6, 3, 2, 1},
        {1, 2, 0, 1, 5},
        {4, 1, 0, 1, 7},
    };
    // 除了行数、列数，还需要传递一个寻址函数
    OY::SegBITSumTree<false, uint32_t, 1000, 10000> T(4, 5, [&](int i, int j) { return matrix[i][j]; });
    cout << T << endl;
    // 输出[0,2]行，[1,4]列的和
    cout << "sum(matrix[0~2][1~4])=" << T.query(0, 2, 1, 4) << endl;
}
```

```
#输出如下
[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7]]
sum(matrix[0~2][1~4])=27

```

